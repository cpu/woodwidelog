<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Why is Rust OpenSSL suddenly making invalid SANs? - Wood Wide Log</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content='If you have a Rust app that uses the openssl crate to generate
certificates (or certificate signing requests), and one day out of the blue
those certs. or CSRs are being rejected for malformed subject alternative names
(SANs) with confusing errors like:

certificate is valid for example.com, www.example.com, not example.com

or:

Cannot issue for "example.com, dns:www.example.com": Domain name contains an invalid character

Then the root cause is almost certainly that your app was relying on an API quirk
in the openssl crate that went away with a bugfix that landed in 2023.'><meta property="og:image" content><meta property="og:url" content="https://log.woodweb.ca/articles/openssl-rs-sans/"><meta property="og:site_name" content="Wood Wide Log"><meta property="og:title" content="Why is Rust OpenSSL suddenly making invalid SANs?"><meta property="og:description" content='If you have a Rust app that uses the openssl crate to generate certificates (or certificate signing requests), and one day out of the blue those certs. or CSRs are being rejected for malformed subject alternative names (SANs) with confusing errors like:
certificate is valid for example.com, www.example.com, not example.com
or:
Cannot issue for "example.com, dns:www.example.com": Domain name contains an invalid character
Then the root cause is almost certainly that your app was relying on an API quirk in the openssl crate that went away with a bugfix that landed in 2023.'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2024-10-05T08:00:00-04:00"><meta property="article:modified_time" content="2024-10-05T08:00:00-04:00"><meta property="og:image" content="https://log.woodweb.ca/2022/10/wwl/crow.small.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://log.woodweb.ca/2022/10/wwl/crow.small.jpg"><meta name=twitter:title content="Why is Rust OpenSSL suddenly making invalid SANs?"><meta name=twitter:description content='If you have a Rust app that uses the openssl crate to generate certificates (or certificate signing requests), and one day out of the blue those certs. or CSRs are being rejected for malformed subject alternative names (SANs) with confusing errors like:
certificate is valid for example.com, www.example.com, not example.com
or:
Cannot issue for "example.com, dns:www.example.com": Domain name contains an invalid character
Then the root cause is almost certainly that your app was relying on an API quirk in the openssl crate that went away with a bugfix that landed in 2023.'><script src=https://log.woodweb.ca/js/feather.min.js></script><link href=https://log.woodweb.ca/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://log.woodweb.ca/css/main.5cebd7d4fb2b97856af8d32a6def16164fcf7d844e98e236fcb3559655020373.css><link rel=stylesheet type=text/css href=https://log.woodweb.ca/css/custom.d10d882a0feb2833d6bb41c11b088fd0710c01566f5092017beb42fa48bc7762.css></head><body><div class=content><header><div class=main><a href=https://log.woodweb.ca/>Wood Wide Log</a></div><nav><a href=/>Log</a>
<a href=/articles>Articles</a>
<a href=/posts>Archive</a>
<a href=/about>About</a></nav></header><main><article><div class=title><h1 class=title>Why is Rust OpenSSL suddenly making invalid SANs?</h1><div class=meta>Posted on Oct 5, 2024</div></div><section class=body><p>If you have a Rust app that uses the <a href=https://crates.io/crates/openssl>openssl crate</a> to generate
certificates (or certificate signing requests), and one day out of the blue
those certs. or CSRs are being rejected for malformed subject alternative names
(SANs) with confusing errors like:</p><blockquote><p><code>certificate is valid for example.com, www.example.com, not example.com</code></p></blockquote><p>or:</p><blockquote><p><code>Cannot issue for "example.com, dns:www.example.com": Domain name contains an invalid character</code></p></blockquote><p>Then the root cause is almost certainly that your app was relying on an API quirk
in the <code>openssl</code> crate that went away with a bugfix that landed in 2023.</p><h1 id=the-short-story>The short story</h1><p>While I find the longer story interesting, if you just want to fix your app
immediately you should:</p><ul><li>Check if you, or a transitive dependency, updated to <code>openssl >= 0.10.48</code>.</li><li>Replace any invocations of <a href=https://docs.rs/openssl/latest/openssl/x509/extension/struct.SubjectAlternativeName.html>SubjectAlternativeName</a> builder fns that were
provided comma separated values to use one builder invocation per value
instead:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Bad:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> example <span style=color:#f92672>=</span> SubjectAlternativeName::new()
</span></span><span style=display:flex><span>    .dns(<span style=color:#e6db74>&#34;example.com, DNS:www.example.com&#34;</span>)
</span></span><span style=display:flex><span>    .ip(<span style=color:#e6db74>&#34;127.0.0.1, IP:8.8.8.8&#34;</span>)
</span></span><span style=display:flex><span>    .build(<span style=color:#f92672>..</span>.)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Good:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> example <span style=color:#f92672>=</span> SubjectAlternativeName::new()
</span></span><span style=display:flex><span>    .dns(<span style=color:#e6db74>&#34;example.com&#34;</span>)
</span></span><span style=display:flex><span>    .dns(<span style=color:#e6db74>&#34;www.example.com&#34;</span>)
</span></span><span style=display:flex><span>    .ip(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>)
</span></span><span style=display:flex><span>    .ip(<span style=color:#e6db74>&#34;8.8.8.8&#34;</span>)
</span></span><span style=display:flex><span>    .build(<span style=color:#f92672>..</span>.)
</span></span></code></pre></div><p>If you <em>haven&rsquo;t</em> updated <code>openssl</code> past that point then I&rsquo;m afraid this story
won&rsquo;t help you fix your bug (and you are missing security fixes for
vulnerabilities!).</p><p>If you&rsquo;re interested in gory OpenSSL themed horror, read on.</p><h1 id=the-long-story>The long story</h1><p>I first bumped into this situation after <a href=https://github.com/rustls/rustls/issues/1292>rustls#1292</a> was created by
a user confused by an error emitted by Rustls when talking to a server using
a certificate generated with the Rust <code>openssl</code> crate. I bumped into it <em>again</em>
this week after helping a friend debug a problem with a Rust ACME client,
prompting the idea to write this stuff down :)</p><h2 id=beware-openssl-text>Beware OpenSSL text</h2><p>Often the first thing folks reach for in these cases is the <code>openssl</code> command
line tool to dump a textual representation of a problematic PEM encoded X.509
certificate to check its subject alternative names:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>openssl x509 -in $PATH_TO_PEM_CERT -noout -text | <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  grep --after-context<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> <span style=color:#e6db74>&#34;Subject Alternative Name:&#34;</span>
</span></span></code></pre></div><p>Which in the case of <a href=https://gist.github.com/cpu/43697ca55fccd04e91f66540ea66ae62>the cert provided</a> in issue 1292, printed:</p><pre tabindex=0><code>    X509v3 Subject Alternative Name:
        DNS:localhost, IP:127.0.0.1, DNS:localhost
</code></pre><p>The duplicate <code>"localhost"</code> <code>dNSName</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> type SAN stands out, but I&rsquo;ll spoil the
surprise a bit and say it&rsquo;s a red herring. The real issue is that OpenSSL&rsquo;s
text output is a pretty crummy tool for this sort of debugging. It&rsquo;s deceived us
by not providing any delimiters around each SAN&rsquo;s <code>GeneralName</code> values! What
appears to be <em>three</em> SANs is actually just <strong>two</strong>.</p><ol><li>One <code>dNSName</code> type general name with the value <code>"localhost, IP:127.0.0.1"</code></li><li>One <code>dNSName</code> type general name with the value <code>"localhost"</code></li></ol><p>You can verify this with a more capable low-level tool like <a href=https://github.com/google/der-ascii>der-ascii</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>der2ascii -pem -i $PATH_TO_PEM_CERT
</span></span></code></pre></div><p>This will print a lot decoded ASN.1 data<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, but most importantly, the <code>subjectAltName</code>
extension where the invalid SAN problem is easily visible:</p><pre tabindex=0><code>&lt;snipped&gt;
SEQUENCE {
  # subjectAltName
  OBJECT_IDENTIFIER { 2.5.29.17 }
  OCTET_STRING {
    SEQUENCE {
      [2 PRIMITIVE] { &#34;localhost, IP:127.0.0.1&#34; }
      [2 PRIMITIVE] { &#34;localhost&#34; }
    }
  }
}
&lt;snipped&gt;
</code></pre><p>A valid certificate for both <code>localhost</code> and <code>127.0.0.1</code> should instead have
a SAN extension like<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><pre tabindex=0><code>&lt;snipped&gt;
SEQUENCE {
  # subjectAltName
  OBJECT_IDENTIFIER { 2.5.29.17 }
  OCTET_STRING {
    SEQUENCE {
      [2 PRIMITIVE] { &#34;localhost&#34; }
      [7 PRIMITIVE] { `7f000001` }
    }
  }
}
&lt;snipped&gt;
</code></pre><p>If we make that change and then run the text back through <code>ascii2der</code> we can see
how <code>openssl x509</code> would display the proper encoding in textual form. The
difference is quite subtle!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>ascii2der -i $PATH_TO_EDITED_TXT | <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  openssl x509 -inform der -noout -text | <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    grep --after-context<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> <span style=color:#e6db74>&#34;Subject Alternative Name: &#34;</span>
</span></span></code></pre></div><pre tabindex=0><code>DNS:localhost, IP Address:127.0.0.1
</code></pre><p>The observant will note the prefix of the IP address SAN is now shown as &ldquo;IP
Address:&rdquo;, not &ldquo;IP:&rdquo; like we saw with the malformed cert.</p><p>OpenSSL also has a way to dump a more accurate ASN.1 representation of the
certificate DER (<code>openssl asn1parse</code>) but it&rsquo;s lackluster compared to
<code>der-ascii</code> and only shows the whole SAN extension as a hex encoded octet
string. It&rsquo;s also perhaps not a great idea to be piping data that might be
malformed in some way through a tool written in C with a history of memory
safety vulns in its parsing code&mldr; In contrast, <code>der-ascii</code> is written in Go.</p><p>In either case I think we can all agree this certificate is busted: it has
a clearly invalid <code>dNSName</code> SAN and no <code>iPAddress</code> SAN at all.</p><h2 id=what-changed>What changed?</h2><p>Knowing the problem with the certificate doesn&rsquo;t explain why certificate
generation code that <em>used to</em> produce valid certificates is now producing
certificates with freak-show conjoined SANs.</p><p>In the case of issue 1292 the generation code in question used the <a href=https://crates.io/crates/openssl>openssl
crate</a> and was building the <a href=https://docs.rs/openssl/latest/openssl/x509/extension/struct.SubjectAlternativeName.html>SubjectAlternativeName</a> as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> subject_alt_name <span style=color:#f92672>=</span> SubjectAlternativeName::new()
</span></span><span style=display:flex><span>        .dns(<span style=color:#e6db74>&#34;localhost, IP:127.0.0.1&#34;</span>)
</span></span><span style=display:flex><span>        .build(<span style=color:#f92672>&amp;</span>cert_builder.x509v3_context(Some(<span style=color:#f92672>&amp;</span>ca_cert_x590), None))<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>This pointed to the root cause being a change in the way the <a href=https://docs.rs/openssl/latest/openssl/x509/extension/struct.SubjectAlternativeName.html#method.dns>dns()</a> fn
handled values. It&rsquo;s not a large leap to theorize it must have previously
allowed specifying multiple comma-separated values and now is treating it as one
domain name value.</p><p>The old behaviour does seem confusing: it was using <code>dns()</code> but also providing an
<code>IP:</code> prefixed SAN value. Shouldn&rsquo;t it have used the <code>ip()</code> fn for that?
Changing <code>dns()</code> to disallow that kind of mixed usage seems like great sense.
With this insight in hand it didn&rsquo;t take long to backtrack to
<a href=https://github.com/sfackler/rust-openssl/pull/1854>rust-openssl#1854</a>, &ldquo;Fix a series of security issues&rdquo;.</p><p>but wait&mldr; Security issues? I thought we were just chasing down a benign API
change&mldr;&mldr;..</p><h2 id=horror-shows>Horror Shows</h2><p>The change in question was to fix <a href=https://rustsec.org/advisories/RUSTSEC-2023-0023.html>RUSTSEC-2023-0023</a>, a bug reported by <a href=https://davidben.net/>David
Benjamin</a> that says:</p><blockquote><p>SubjectAlternativeName and ExtendedKeyUsage arguments were parsed using the
OpenSSL function X509V3_EXT_nconf. This function parses all input using an
OpenSSL mini-language which can perform arbitrary file reads.</p></blockquote><p>ðŸ˜± &ldquo;an OpenSSL mini-language&rdquo;.</p><p>ðŸ˜±ðŸ˜± &ldquo;which can perform arbitrary file reads&rdquo;.</p><p>I believe this situation was correctly summarized by <a href=https://alexgaynor.net/>Alex Gaynor</a> as
a <a href=https://github.com/sfackler/rust-openssl/pull/1854/commits/a7528056c5be6f3fbabc52c2fd02882b208d5939>horror show</a> and certainly seemed perfect for a spooky October blog post.</p><h1 id=stop-the-madness>Stop the Madness</h1><p>So now we understand why the certificate is invalid, when & why the <code>openssl</code>
crate changed its <code>SubjectAlternativeName</code> builder behaviour, and how OpenSSL
continues to provide new and exciting ways to shoot your feet off.</p><p>I&rsquo;d be remiss if I didn&rsquo;t close this story by suggesting it might be time to
reconsider your OpenSSL dependencies.</p><p>For certificate generation needs consider <a href=https://github.com/rustls/rcgen>rcgen</a> for simpler situations, or the
Rust Crypto project&rsquo;s <a href=https://docs.rs/x509-cert/latest/x509_cert/>x509-cert</a> crate if you have more complex needs. For TLS,
consider <a href=https://github.com/rustls/rustls>rustls</a>. It&rsquo;s safer, and faster too.</p><p>Your sanity deserves it.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The odd looking casing for <code>dNSName</code> and <code>iPAddress</code> is a quirk of RFC 5280.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Check out <a href=https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/>A Warm Welcome to ASN.1 and DER</a> and <a href=https://www.rfc-editor.org/rfc/rfc5280>RFC 5280</a> if you&rsquo;re curious about understanding the full <code>der-ascii</code> output.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Note that <code>0x7f000001</code> is the hex encoding of the network-byte-order IPv4 &ldquo;127.0.0.1&rdquo; address.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://log.woodweb.ca/index.xml title=RSS><i data-feather=rss></i></a>
<a class=border></a><a class=soc href=https://github.com/cpu/woodwidelog title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/cpu/ title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2024 Daniel McCarney</div></footer><script>feather.replace()</script></div></body></html>